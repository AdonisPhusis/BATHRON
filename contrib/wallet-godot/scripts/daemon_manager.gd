extends Node
## BATHRON Daemon Manager - Auto-launch and manage bathrond lifecycle
## Handles starting/stopping the daemon when the wallet opens/closes

signal daemon_started
signal daemon_stopped
signal daemon_error(message: String)
signal daemon_ready  # Emitted when RPC is responsive

const DAEMON_CHECK_INTERVAL := 2.0  # seconds
const DAEMON_STARTUP_TIMEOUT := 30.0  # seconds
const RPC_PORT_MAINNET := 51473
const RPC_PORT_TESTNET := 51475

var _daemon_pid: int = -1
var _daemon_process: int = -1
var _check_timer: Timer
var _startup_timer: Timer
var _is_testnet: bool = true  # Default to testnet for safety
var _daemon_path: String = ""
var _data_dir: String = ""

func _ready() -> void:
	_setup_paths()
	_ensure_config()
	_create_timers()

	# Auto-start daemon on ready
	call_deferred("start_daemon")

func _setup_paths() -> void:
	var exe_dir := OS.get_executable_path().get_base_dir()

	# Check if we're in a macOS .app bundle
	if exe_dir.ends_with("MacOS"):
		# Inside .app bundle: BATHRON-Wallet.app/Contents/MacOS/
		_daemon_path = exe_dir.path_join("bathrond")
	else:
		# Development mode or standalone
		_daemon_path = exe_dir.path_join("bathrond")

	# Fallback: check common locations
	if not FileAccess.file_exists(_daemon_path):
		var fallbacks := [
			"/usr/local/bin/bathrond",
			"/opt/homebrew/bin/bathrond",
			OS.get_environment("HOME") + "/bathrond",
			OS.get_environment("HOME") + "/BATHRON/src/bathrond",
		]
		for path in fallbacks:
			if FileAccess.file_exists(path):
				_daemon_path = path
				break

	# Data directory
	_data_dir = OS.get_environment("HOME") + "/.bathron"

	print("[DaemonManager] Daemon path: ", _daemon_path)
	print("[DaemonManager] Data dir: ", _data_dir)

func _ensure_config() -> void:
	## Create bathron.conf with default seeds if it doesn't exist
	var config_path := _data_dir + "/bathron.conf"

	# Create data directory if needed
	if not DirAccess.dir_exists_absolute(_data_dir):
		DirAccess.make_dir_recursive_absolute(_data_dir)
		print("[DaemonManager] Created data dir: ", _data_dir)

	# Create config with seeds if missing
	if not FileAccess.file_exists(config_path):
		var config := """# BATHRON Configuration (auto-generated by wallet)
server=1
rpcuser=walletuser
rpcpassword=walletpass123
rpcallowip=127.0.0.1
addnode=57.131.33.151:27171
addnode=162.19.251.75:27171
addnode=57.131.33.152:27171
addnode=57.131.33.214:27171
addnode=51.75.31.44:27171
"""
		var file := FileAccess.open(config_path, FileAccess.WRITE)
		if file:
			file.store_string(config)
			file.close()
			print("[DaemonManager] Created config: ", config_path)
	else:
		print("[DaemonManager] Config exists: ", config_path)

func _create_timers() -> void:
	_check_timer = Timer.new()
	_check_timer.wait_time = DAEMON_CHECK_INTERVAL
	_check_timer.timeout.connect(_on_check_timer)
	add_child(_check_timer)

	_startup_timer = Timer.new()
	_startup_timer.one_shot = true
	_startup_timer.wait_time = DAEMON_STARTUP_TIMEOUT
	_startup_timer.timeout.connect(_on_startup_timeout)
	add_child(_startup_timer)

func _exit_tree() -> void:
	# Optionally stop daemon when wallet closes
	# For now, leave it running (user might want background sync)
	pass

# ============================================================================
# PUBLIC API
# ============================================================================

func start_daemon() -> bool:
	## Start bathrond if not already running

	if is_daemon_running():
		print("[DaemonManager] Daemon already running")
		daemon_ready.emit()
		return true

	if not FileAccess.file_exists(_daemon_path):
		var msg := "bathrond not found at: " + _daemon_path
		push_error(msg)
		daemon_error.emit(msg)
		return false

	print("[DaemonManager] Starting daemon...")

	# Build command arguments
	var args: PackedStringArray = ["-daemon"]
	if _is_testnet:
		args.append("-testnet")

	# Start the process
	_daemon_process = OS.create_process(_daemon_path, args)

	if _daemon_process <= 0:
		var msg := "Failed to start bathrond"
		push_error(msg)
		daemon_error.emit(msg)
		return false

	print("[DaemonManager] Daemon process started: ", _daemon_process)

	# Start waiting for RPC to be ready
	_startup_timer.start()
	_check_timer.start()

	return true

func stop_daemon() -> bool:
	## Stop bathrond gracefully via RPC

	if not is_daemon_running():
		print("[DaemonManager] Daemon not running")
		return true

	print("[DaemonManager] Stopping daemon...")

	# Try graceful stop via bathron-cli
	var cli_path := _daemon_path.replace("bathrond", "bathron-cli")
	var args: PackedStringArray = ["stop"]
	if _is_testnet:
		args.insert(0, "-testnet")

	if FileAccess.file_exists(cli_path):
		OS.create_process(cli_path, args)

		# Wait a bit for graceful shutdown
		await get_tree().create_timer(3.0).timeout

	_check_timer.stop()
	daemon_stopped.emit()
	return true

func is_daemon_running() -> bool:
	## Check if bathrond is running (by checking lock file or process)

	var lock_file := _data_dir
	if _is_testnet:
		lock_file += "/testnet5/.lock"
	else:
		lock_file += "/.lock"

	return FileAccess.file_exists(lock_file)

func get_rpc_port() -> int:
	return RPC_PORT_TESTNET if _is_testnet else RPC_PORT_MAINNET

func set_testnet(enabled: bool) -> void:
	_is_testnet = enabled

func get_cookie_path() -> String:
	var path := _data_dir
	if _is_testnet:
		path += "/testnet5/.cookie"
	else:
		path += "/.cookie"
	return path

# ============================================================================
# INTERNAL
# ============================================================================

func _on_check_timer() -> void:
	if is_daemon_running():
		# Check if RPC is responsive
		if _is_rpc_ready():
			_check_timer.stop()
			_startup_timer.stop()
			print("[DaemonManager] Daemon is ready!")
			daemon_started.emit()
			daemon_ready.emit()

func _on_startup_timeout() -> void:
	_check_timer.stop()
	var msg := "Daemon startup timeout after " + str(DAEMON_STARTUP_TIMEOUT) + "s"
	push_error(msg)
	daemon_error.emit(msg)

func _is_rpc_ready() -> bool:
	# Check if cookie file exists (indicates RPC is ready)
	return FileAccess.file_exists(get_cookie_path())
